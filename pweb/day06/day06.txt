day06
	
cookie:
	size = os.path.getsize('file')
		功能：获取文件的大小

创建自己的进程类：
	
多进程：	
	优点：并行多个任务，提高运行效率
		 空间独立，数据安全，创建方便

	缺点：进程创建销毁的过程中消耗较多的计算机资源

进程池：
	背景：在需要频繁的创建删除较多进程的情况下，导致计算机资源消耗过多
	功能：有多个进程一直处理不同的事件

	流程：
		1.创建进程池，在池内放入适量的进程
		2.将事件加入进程池等待队列
		3.使用进程池中的进程不断处理事件
		4.所有事件处理后，回收关闭进程池

	实现：
		from multiprocessing import Pool

		Pool()
			功能：创建进程池
			参数：processes:指定进程池中进程数量
			返回：得到进程池对象

		poll.apply_async()
			功能：异步方式将事件放入进程池执行
			参数：func:要执行的事件函数
				 args:同Process中的args 给函数传参
				 kwds:以字典方式给函数传参
			返回值：apply_async 对象，可对此对象使用get方法获取传入函数的返回值
		pool.close() 
			功能：关闭进程池，使其无法加入新的事件
		pool.join()
			功能：阻塞等待进程池退出（当所有事件执行完毕后)
		pool.apply()
			用法和apply_async一样，只是需要顺序执行，一个事件结束再执行另一个事件
		pool.map(func,iter)
			功能：类似于内建函数map，将第二个参数的迭代传递给第一个参数的函数执行，同时兼容了使用进程池执行
			返回值：返回func的返回值列表

进程间的通信
	1.进程间通过磁盘交互进行通信的缺点：
		1.速度慢
		2.不安全

	2.进程间可以通过socket来进行网络和本地的通信

	3.其他线程间通信方法：
		1.管道
			原理：在内存中开辟一块空间，对多个进程可见，通过管道，多进程进行通信
			实现：
				fd1,fd2 = multiprocessing.Pipe(duplex = True)
					功能：创建一个管道
					参数：duplex默认为True 表示双向管道，False为单向管道
					返回值：返回两个管道流对象，表示管道的两端
							如果是双向管道，则两个均可读写
							如果是单向管道，则fd1只能读，fd2只能写
				fd1.recv() 
					功能:接收消息
					参数：无
					返回值：接收到的消息
					*如果管道没有消息会阻塞
				fd2.send(data)
					功能:发送消息
					参数：要发送的内容
					返回值：无
					*如果没有接收端则管道破裂
			示例：pipe.py

		2.消息队列
			队列的概念：先进先出的数据结构
			原理：在内存中开辟队列模型，用来存放消息，任何拥有队列的进程都可以存取消息
			实现：	
				创建队列：
				q = multiprocessing.Queue(maxsize = 0)
					功能：创建一个消息队列
					参数：maxsize默认为0，表示队列可存放消息由内存而定
								>0,表示队列最多存放多少条消息
					返回值：返回消息队列对象
				q.put()
					功能：向队列中存放消息(字符串，整数，列表)
					参数：要存的消息(字符串，整数，列表)
					*当队列满时会阻塞
				q.full()
					功能：队列是否为满，满返回True
				q.get()
					功能：向队列取出消息
					返回值：取出的消息
					*当队列为空时会阻塞
				q.empty()
					功能：队列是否为空，空返回True
				q.qsize()
					功能：得到当前消息中消息的个数

				*put,get 中均有可选参数block和timeout
					block 默认为True,表示阻塞函数，如果设置为False则不阻塞
					timeout block为True,设置超时时间

		3.共享内存
			原理：在内存中开辟一个空间，存储数据，对多个进程可见，每次写入共享内存的数据会覆盖之前的内容，由于对内存格式化较少，所以存取速度快
			实现：
				1.from multiprocessing import Value（多用于单个数据类型)
					obj = Value(ctype,obj)
						功能：开辟共享内存空间
						参数: ctype str 要转变的c类型 (对照ctype表)
							 obj 写入共享内存的初始值
						返回值：返回一个共享内存对象
					obj.value
						功能：获得共享内存中的值
				2.from multiprocessing import Array(多用于多个数据类型)
					obj = Array(ctype,obj)
						功能：开辟共享内存空间
						参数: ctype str 要转变的c类型 (对照ctype表)
							 obj 写入共享内存的数据
							 	 如果是一个列表，要求列表中数据类型一致
							 	 如果是一个正整数，则表示开辟一个多大的序列空间
						返回值：返回一个共享内存对象
		4.信号
			原理：一个进程向另一个进程通过信号传递某种讯息
			终端命令： 
				kill -l  查看信号
				kill -signame PID 给PID的进程发送一个信号
			关于信号：
				1.信号名称：系统定义，信号的名字
				2.信号的含义：系统定义，信号的作用
				3.信号的默认处理方法：系统定义，信号给接收进程带来的行为一般有终止，暂停，忽略


			信号名称             信号的含义          信号的默认处理方法
			————————————————————————————————————————————————————————————
			SIGINT
			SIGQUIT
			SIGKILL
			SIGALRM
			SIGSTOP
			SIGTSTP
			SIGCHILD

			python如何操作信号

				os.kill(pid,sig)
					功能：下一个进程发送一个信号
					参数：pid 要发送信号的进程PID
						 sig 发送的信号

				signal.alarm(sec)
					功能：向自身发送一个时钟信号SIGALRM
					参数：sec 时钟秒数

			*信号属于异步通信方式，信号的发送不会影响进程的持续执行
			*在一个进程中只能同时有一个时钟，后面的时钟时间会覆盖前面的

			处理：
				signal.pause()
					功能：阻塞等待一个信号的发生
				signal.signal(signum,handler)
					功能：处理一个信号
					参数：signum:要处理的信号
						 handler:对该信号的处理方法
						 		1.SIG_DFL 使用默认处理方法
						 		2.SIG_IGN 忽略这个信号
						 		3.func    回调函数（高阶函数的一种）
						 				  表示使用自定义的方法来处理
				func格式要求：
					def func(sig,frame):
						...
					形参：sig==>接收到的信号
					     frame ==> 信号对象

			*signal 函数是一个异步处理信号函数，只要执行，在进程中就会按照指定方法处理信号
			*signal 不能处理SIGSTOP SIGKILL信号

		5.信号量
			见day07.txt

	
	4. 管道，消息队列，共享内存的比较
			               管道               消息队列             共享内存
		————————————————————————————————————————————————————————————————————————————
		开辟空间            内存                内存                 内存
		            
		读写方式            双向/单向           先进先出              操作覆盖内存
		
		效率                一般               一般                 快
		
		应用               多用于亲缘进程       方便灵活广泛           较复杂

		是否需要互斥机制       否                否                   需要



作业：
	1.对进程间通信方式进行描述练习
	2.熟悉进程间通信代码