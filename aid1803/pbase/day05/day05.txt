day04 回顾

break && continue
    break语句
        作用：用于循环语句(for,while)中，用来终止当前的循环语句的执行
    continue语句：
    作用：用在循环语句当中(for,while)中，跳过本次continue之后的语句，执行下一次循环

    
for语句
    作用：用来遍历可迭代对象
    语法：
        for i in 可迭代对象：
            语句块
可迭代对象: 字符串，列表，range(x)

for 嵌套
    for i in 'abc':
        for j in '123':
            print(i+j,end = ',')
    ==> a1,a2,a3,b1,b2,b3,c1,c2,c3

range(x)     #1~x
range(x,y)   #x~y，每次递增1
range(x,y,z) #x~y，每次递增z

列表
    l=[]
    l=list(可迭代对象)
算数运算:
    +
    +=
    ×
    ×=
比较运算符：
    > >= < <= == !=

in/not in
对象 in 列表

列表的索引
    列表[索引]
列表索引取值和赋值：
    列表[索引]=新对象
列表的切片
    列表[(起始索引):(终止索引):(步进)]
切片赋值和插入
    l = [1,2,3,4]
    l[0:0]=1.1
    l[::2]=[1.1,3.3]
    l[0:2]=[1]
del l[0]
del l[::]

python3里常用的序列函数
len(seq)
max(x)
min(x)
sum(x)
any(x)
all(x)

列表的常用方法：
l=[1,2,3,4]
l.index(1[,begin[,end]]) ==> 0
l.insert(index,obj)
l.count(2) ==> 1
l.remove(2) ==> 删除列表中第一次出现的2
l.append(2) ==> 在列表的末尾添加2
l.extend([1,2])
l.clear()
l.sort(reverse = False)
l.reverse()
l.pop([index])
l.copy() 复制（浅拷贝）

+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
day05
l1 = [1,2]
l2 = [l1,3,4]
l3 = l2.copy()
l1
[1, 2]
l2
[[1, 2], 3, 4]
l3
[[1, 2], 3, 4]
l1[0] = 1.1
l2
[[1.1, 2], 3, 4] 改变l1 后，l2,l3均发生改变
l3
[[1.1, 2], 3, 4]
l2[1] = 3.3
l2
[[1.1, 2], 3.3, 4]改变l2后，l2,发生改变，但 l3不会会发生改变
l3
[[1.1, 2], 3, 4]
原因是copy为浅拷贝，l1的内容并没有被解读并拷贝，而只是将l1的地址拷贝，所以l3会随着l1的变化而变化

如需深拷贝则使用
    import copy
    l3 = copy.deepcopy(l2)

字符串的文本解析方法视频split()和join()

    s = 'abc'
    s.split(sep = ' ')将字符串使用sep作为分隔符，分割s字符串，返回分割后的字符串列表
    示例：     s = 'abc'
              s.split(sep='b') #['a','c']
    s.join(iterable)用可迭代对象中的字符串，返回一个中间用s进行分割的字符串
    示例：     l = ['a','c']
              'b'.join(l) # 'abc'


练习：
    1.有字符串'hello',生成'hello'和'h-e-l-l-0'
    2.有一些数字，存在与列表中
        l = [1,2,3,5,7,9,5,1,2,3]
    要求将该列表中只出现一次的元素存入另一个列表l2中
    day05practise01.py && day05practise02.py

列表推倒式：List Comprehension
语法：
    [表达式 for 变量 in 可迭代对象]
    [表达式 for 变量 in 可迭代对象 if 真值表达式]
    如：l = [x for x in 可迭代对象]
    如：生成一个[1,4,9,16,...]
    l = [x**2 for x in range(1,5)]
    等同于：
        for x in range(1,5):
            l.append(x**2)
    示例：
        生成1到100的奇数
        l=[x for x in range(1,100) if x % 2 == 1]
练习：
    用列表推倒式生成：
        [2,5,10,4**2+1,5**2+1,37,...,10001]

    l=[x ** 2 + 1 for x in range(1,101)]

    输入一个数值作为开始的数，用begin绑定
    再输入一个结束的整数用end绑定
        将 开始至结束的数中，平方加1能被,7整除的数放入列表中
    请输入开始数：1
    请输入结束数：20
    
列表推倒式的嵌套：
    [表达式 for 变量 in 可迭代对象 if 真值表达式
                for 变量 in 可迭代对象 if 真值表达式]
    如：l = ['a1','a2','a3','b1','b2','b3','c1','c2','c3']
    l=[ i+j for i in 'abc\
             for j in '123]

练习：
    1.输入一个整数n代表结束的数
    将1-n之间所有的素数计算出来并存入到列表L中
        1）最后打印此列表中的全部素数
        2）打印这些素数的和
    
    2.求100以内有哪些整数与自身加1的乘积再对11求余的结果等于8
    x*(x+1)%11 ==8,打印这些数，将这些数存于列表当中（尝试使用列表推导式）
    
    3.计算20个斐波那契数存于列表当中，打印这20个数 1,1,2,3,5,8



元组(tuple)：
    元组是不可变类型，同list一样也可以存放任意类型的元素。
元祖的表示方法：
    用小括号()括起来，单个元素括起来后加逗号，如（1，），如果不加逗号，则是一个对象，如(1)
创建空元组
    t = ()
创建非空元组
    t =100, 
    t = (1,)
    t =(100) #这是一个对象不是元组
    t =(100,200)
type(返回t对象类型)
元组的构造函数（创建函数）
tuple()
tuple(iterable) 用迭代对象生成元组 #tuple('abc')
元组的运算：
    + += * *=
    < <= >= == !=
    in/in not 运算符
    索引（等同于列表索引，但不能索引赋值）
    切片（等同于列表切片，但不能切片赋值）

元组的方法：
    t = (1,2,3)
    t.index(v[,begin[,end]])
        在元素不存在时触发ValueError错误
    t.count(v) 返回元组中对应元素的个数



字典
    什么是字典：
        1.字典是一种可变的容器，可以存储任意类型的数据
        2.字典中每个数据都用'键'(key)进行索引，不像序列(字符串，列表，元组)可以通过索引进行取值
        3.字典是数据是没有先后顺序的，字典的存储是无序的
        4.字典的数据以键值对的形式存储
        5.字典的键不能重复，且只能用不可变类型作为字典的键
    字面值表示方法：
        以{}括起来，用:分割键值对，各键值对用逗号分开
    创建一个空字典
        d = {}
        d = dict()
    dict的创建函数
        d = dict()
        d = dict(iterable) 用可迭代对象来创建字典
        d = dict(**kwargs) 用关键字传参来创建字典

字典的基本操作：
    字典的键索引方法：
        字典[键]
    作用：通过键来获取键所对应的值
    d={1:2,3:4}
    d[1] #2
    d[3] #4
添加和修改字典的元素
    d={}
    语法：
        d[key] = 对象
        d['age'] = 18
        d['name'] = 'xm'
        d['age'] = 20
说明：
    键不存在，则创建键值对
    键若存在，则修改键值绑定值

删除字典的元素：
    del d[key]

字典成员资格判断 in/not in 运算符
    可以用In来判断一个键是否存在与字典中
    not in 与 in返回结果相同
字典的迭代访问：
    列表是可迭代对象，字典只能对键进行迭代访问
    d = {1:'one',2:'two',3:'three'}
    for k in d :
        print(k)
    'one' in d #False
列表的in运算符和字典in运算符比较：
1.列表的in运算符计算时间会因列表中元素个数的增加而增加
2.字典的in运算符计算时间不会因键值对的个数增加而增加，操作速度快于列表


用于字典的一些内建函数
len(d)               返回键值对的个数
max(x)               返回键最大值
min(x)               返回键最小值
sum(x)               返回所有键的和
any(x)               真值测试（针对所有键）
all(x)               真值测试（针对所有键）
d.clear()            清空字典
d.pop(key)           移除键，同时返回键对应的值
d.copy()             返回字典d的副本，只复制一层(浅拷贝)
d.update(d1)         将字典d1合并到d中，如果键相同，则次键值取d1中的值作为新值
d.get(key，default)   返回键的值，如果没有则返回default
帮助 help(dict)

练习：
    输入一段字符串，打印出这个字符串中出现过的字符以及此字符出现的个数
    如：
        请输入：abcdaba
        打印结果如下：
        a:3次
        b:2次
        c:1次
        d:1次
        abcd顺序不强求
练习：
    输入一个整数代表星期几（0-6），‘0’/’日‘代表周日，‘1’/’一‘代表周一，以此类推
    任意输入字符串打印这个字符串是否代表星期几，如果不是以上字符，打印'字典内没有相应的数据'
    （要求将以上数据存于字典中，键为字符串）
    见weekdays.py


字典推倒式：
    是用可迭代对象依次生成字典内的值对的简单方式
语法：
    {键表达式:值表达式 for 变量 in 可迭代对象[if 真值表达式]}
    示例：
        想生成一个字典，键为数字，值为键的平方
        {1:1,2:4,3:9}
        d = {x:x**2 for x in range(1,11)}
字典推倒式的嵌套
    {键表达式:值表达式 for 变量1 in 可迭代对象1[if 真值表达式1]
                        for 变量2 in 可迭代对象2[if 真值表达式2]}
练习:
    1.有字符串列表如下
        l = ['tarena','xiaozhang','hello']
        生成如下字典：
        d = {'terena':6,'xiaozhang':9,'hello':5}
    2.有两个列表：
        no = [1001,1002,1003,1004]
        names = ['Tom','Jerry','Spike','Tyke']
        用no中的编码作为键，以names中的字符串作为值，生成相应的字典

字典和列表
    1.都是可变类型，可以实现增加，删除，修改
    2.索引方式不同，列表用整数，字典用键索引
    3.字典的增删改查的速度可能快于列表
    4.列表的存储是有序的，字典的存储是无序的
    
练习：写一个程序，输入数字，用while循环来判断此数字是否为素数



集合set
    set()创建一个空的集合
    集合是可变的容器
    集合内的数据对象都是唯一的
    集合是无序的数据结构，集合的数据没有先后顺序
    集合内的元素必须是不可变类型
    集合是可迭代对象
    集合是相当于只有键没有值的字典（键则是集合的数据）
创建非空集合
    set(iterable) 用可迭代对象创建一个新的集合对象
    s={1,2,3,4}
    s={1,'abc',True}==> s={'abc',True}
集合的运算
    交集 并集 补集 子集 超集 

& 生成两个集合的交集
    s1 = {1,2,3}
    s2 = {2,3,4}
    s1 & s2 = {2,3}
| 生成两个集合的并集
    s1 = {1,2,3}
    s2 = {2,3,4}
    s1 | s2 = {1,2,3,4}
- 生成两个集合的补集
    s1 = {1,2,3}
    s2 = {2,3,4}
    s1 - s2 = {1}
    s2 - s1 = {4}
^ 生成两个集合的对称补集
    s1 = {1,2,3}
    s2 = {2,3,4}
    s1 ^ s2 = {1,4}
.> 判断一个集合是另一个集合的超集
.< 判断一个集合是另一个集合的子集

in/ not in运算符
    等同于前面所学的in运算符，用于判断一个值是否在集合中

练习：
    经理有：曹操，刘备，周瑜
    技术员有：曹操，周瑜，张飞，赵云
    用集合求：
        1.即是经理又是技术员有谁
        2.是经理但不是技术员有谁
        3.是技术员，不是经理有谁
        4.张飞是经理吗
        5.身兼一职的人都有谁
        6.经理和技术员一共有几个人

python3中集合的常用方法：
s代表集合
s.add(e) #向集合中添加新元素e,如果e存在，则不添加
s.remove(e) #从集合中删除一个元素，如果元素不存在于集合中，则会产生一个KeyError错误
s.discard(e)#从集合中删除一个元素，如果不存在，也不会产生错误
s.clear() #清空集合
s.copy()  #将集合进行浅拷贝
s.pop()   #从集合中随机删除一个元素，如果集合为空，则发生KeyError错误
s.update(s1) 用s1与s2得到的并集更新集合s
集合是可迭代对象，可以用for循环来遍历


练习：
    任意输入一些英文词，每次输入一个，当输入0时，结束
    打印输入的单词的个数（去重），打印到单词的终端
    如：
        ABC
        abc
        ABCD
        abc
        单词个数：3
        单词如下：
        abc
        ABC
        ABCD

集合推倒式：
    作用：
        用可迭代对象创建集合
    语法：
        {表达式 for x in 可迭代对象 if [真值表达式]}
        []部分可以省略

固定集合frozenset
    固定集合是不可变，无序的，含有唯一元素的集合
    list --- tuple
    set ---- frozenset
创建空的固定集合
frozenset()
创建非空固定集合
    s= frozenset(iterable)
    如s= frozenset([1,2,3])
运算同集合一样
固定集合的方法：
相当于集合的全部方法去掉修改集合的方法
去掉s.add(),s.remove(),s.pop()


练习：
输入一个Unicode的开始值 用变量begin绑定
输入一个。。。。。结束值，用变量stop绑定
打印开始值至结束值之间的所有对应文字

2.输入一个整数（代表树干的高度）
    打印如下一颗圣诞树
输入2
    ×
   ×××
    ×
    ×
输入3
    ×
   ×××
  ×××××
    ×
    ×
    ×
3.将第二题改为输出：
    1
   222
  33333
    ×
    ×
    ×
4.输入一个正整数，打印这个数是否是素数

